\hypertarget{group__vSemaphoreCreateMutex}{}\section{v\+Semaphore\+Create\+Mutex}
\label{group__vSemaphoreCreateMutex}\index{v\+Semaphore\+Create\+Mutex@{v\+Semaphore\+Create\+Mutex}}
semphr. h 
\begin{DoxyPre}xSemaphoreHandle \hyperlink{semphr_8h_aa6a00aa9b91a9e5b3ebe4ae1c3f115c6}{xSemaphoreCreateMutex( void )}\end{DoxyPre}


{\itshape Macro} that implements a mutex semaphore by using the existing queue mechanism.

Mutexes created using this macro can be accessed using the \hyperlink{semphr_8h_af116e436d2a5ae5bd72dbade2b5ea930}{x\+Semaphore\+Take()} and \hyperlink{semphr_8h_aae55761cabfa9bf85c8f4430f78c0953}{x\+Semaphore\+Give()} macros. The \hyperlink{semphr_8h_ad395f4bba51eea6af3397d72bc079e4d}{x\+Semaphore\+Take\+Recursive()} and \hyperlink{semphr_8h_a398d66b17856c22dd49d39aaac42f105}{x\+Semaphore\+Give\+Recursive()} macros should not be used.

This type of semaphore uses a priority inheritance mechanism so a task \textquotesingle{}taking\textquotesingle{} a semaphore M\+U\+ST A\+L\+W\+A\+YS \textquotesingle{}give\textquotesingle{} the semaphore back once the semaphore it is no longer required.

Mutex type semaphores cannot be used from within interrupt service routines.

See \hyperlink{semphr_8h_ae10bffadd26fbd5bcce76bf33a83ef30}{v\+Semaphore\+Create\+Binary()} for an alternative implementation that can be used for pure synchronisation (where one task or interrupt always \textquotesingle{}gives\textquotesingle{} the semaphore and another always \textquotesingle{}takes\textquotesingle{} the semaphore) and from within interrupt service routines.

\begin{DoxyReturn}{Returns}
x\+Semaphore Handle to the created mutex semaphore. Should be of type x\+Semaphore\+Handle.
\end{DoxyReturn}
Example usage\+: 
\begin{DoxyPre}
xSemaphoreHandle xSemaphore;\end{DoxyPre}



\begin{DoxyPre}void vATask( void * pvParameters )
\{
   // Semaphore cannot be used before a call to \hyperlink{semphr_8h_aa6a00aa9b91a9e5b3ebe4ae1c3f115c6}{xSemaphoreCreateMutex()}.
   // This is a macro so pass the variable in directly.
   xSemaphore = \hyperlink{semphr_8h_aa6a00aa9b91a9e5b3ebe4ae1c3f115c6}{xSemaphoreCreateMutex()};\end{DoxyPre}



\begin{DoxyPre}   if( xSemaphore != NULL )
   \{
       // The semaphore was created successfully.
       // The semaphore can now be used.  
   \}
\}
\end{DoxyPre}


semphr. h 
\begin{DoxyPre}xSemaphoreHandle \hyperlink{semphr_8h_a1bbc843be5a41ea83d2693b2189fc0f8}{xSemaphoreCreateRecursiveMutex( void )}\end{DoxyPre}


{\itshape Macro} that implements a recursive mutex by using the existing queue mechanism.

Mutexes created using this macro can be accessed using the \hyperlink{semphr_8h_ad395f4bba51eea6af3397d72bc079e4d}{x\+Semaphore\+Take\+Recursive()} and \hyperlink{semphr_8h_a398d66b17856c22dd49d39aaac42f105}{x\+Semaphore\+Give\+Recursive()} macros. The \hyperlink{semphr_8h_af116e436d2a5ae5bd72dbade2b5ea930}{x\+Semaphore\+Take()} and \hyperlink{semphr_8h_aae55761cabfa9bf85c8f4430f78c0953}{x\+Semaphore\+Give()} macros should not be used.

A mutex used recursively can be \textquotesingle{}taken\textquotesingle{} repeatedly by the owner. The mutex doesn\textquotesingle{}t become available again until the owner has called \hyperlink{semphr_8h_a398d66b17856c22dd49d39aaac42f105}{x\+Semaphore\+Give\+Recursive()} for each successful \textquotesingle{}take\textquotesingle{} request. For example, if a task successfully \textquotesingle{}takes\textquotesingle{} the same mutex 5 times then the mutex will not be available to any other task until it has also \textquotesingle{}given\textquotesingle{} the mutex back exactly five times.

This type of semaphore uses a priority inheritance mechanism so a task \textquotesingle{}taking\textquotesingle{} a semaphore M\+U\+ST A\+L\+W\+A\+YS \textquotesingle{}give\textquotesingle{} the semaphore back once the semaphore it is no longer required.

Mutex type semaphores cannot be used from within interrupt service routines.

See \hyperlink{semphr_8h_ae10bffadd26fbd5bcce76bf33a83ef30}{v\+Semaphore\+Create\+Binary()} for an alternative implementation that can be used for pure synchronisation (where one task or interrupt always \textquotesingle{}gives\textquotesingle{} the semaphore and another always \textquotesingle{}takes\textquotesingle{} the semaphore) and from within interrupt service routines.

\begin{DoxyReturn}{Returns}
x\+Semaphore Handle to the created mutex semaphore. Should be of type x\+Semaphore\+Handle.
\end{DoxyReturn}
Example usage\+: 
\begin{DoxyPre}
xSemaphoreHandle xSemaphore;\end{DoxyPre}



\begin{DoxyPre}void vATask( void * pvParameters )
\{
   // Semaphore cannot be used before a call to \hyperlink{semphr_8h_aa6a00aa9b91a9e5b3ebe4ae1c3f115c6}{xSemaphoreCreateMutex()}.
   // This is a macro so pass the variable in directly.
   xSemaphore = \hyperlink{semphr_8h_a1bbc843be5a41ea83d2693b2189fc0f8}{xSemaphoreCreateRecursiveMutex()};\end{DoxyPre}



\begin{DoxyPre}   if( xSemaphore != NULL )
   \{
       // The semaphore was created successfully.
       // The semaphore can now be used.  
   \}
\}
\end{DoxyPre}
 